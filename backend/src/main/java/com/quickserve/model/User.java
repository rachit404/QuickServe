package com.quickserve.model;

import jakarta.persistence.*;
import lombok.*;
import org.springframework.data.annotation.CreatedDate;
import org.springframework.data.annotation.LastModifiedDate;
import org.springframework.data.jpa.domain.support.AuditingEntityListener;

import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;

import com.quickserve.model.enums.UserRole;

/**
 * USER ENTITY
 * 
 * This class represents the 'users' table in the database.
 * Each instance of this class maps to one row in the table.
 * 
 * We have three types of users in QuickServe:
 * 1. CUSTOMER - Books services
 * 2. SERVICE_PROVIDER - Provides services (plumber, electrician, etc.)
 * 3. ADMIN - Manages the platform
 * 
 * DESIGN DECISION:
 * We store all user types in one table with a 'role' column rather than
 * separate tables. This simplifies authentication (one login system) and
 * allows users to potentially have multiple roles in the future.
 * 
 * For service providers, additional details are stored in ServiceProvider entity.
 */
@Entity
@Table(name = "users")
@EntityListeners(AuditingEntityListener.class) // Enables @CreatedDate, @LastModifiedDate
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class User {
    
    /**
     * Primary key - auto-generated by PostgreSQL.
     * 
     * IDENTITY strategy means the database handles ID generation.
     * PostgreSQL uses SERIAL/BIGSERIAL columns for this.
     */
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    /**
     * User's full name.
     * Required field - cannot be null in database.
     */
    @Column(nullable = false)
    private String name;
    
    /**
     * Email serves as the username for authentication.
     * Must be unique across all users.
     */
    @Column(nullable = false, unique = true)
    private String email;
    
    /**
     * IMPORTANT: This stores the HASHED password, never plain text!
     * 
     * We use BCrypt for hashing because:
     * - It's slow (making brute force attacks impractical)
     * - It includes a salt (preventing rainbow table attacks)
     * - Industry standard for password storage
     */
    @Column(nullable = false)
    private String password;
    
    /**
     * User's phone number for notifications and verification.
     */
    @Column(name = "phone_number")
    private String phoneNumber;
    
    /**
     * User role determines what they can do in the system.
     * 
     * EnumType.STRING stores the enum name as a string in the database.
     * This is more readable than ORDINAL (which stores as integers).
     * If someone looks at the database directly, they see "CUSTOMER" not "0".
     */
    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private UserRole role;
    
    /**
     * Whether the user has verified their email.
     * New users start with emailVerified = false.
     */
    @Column(name = "email_verified")
    @Builder.Default
    private boolean emailVerified = false;
    
    /**
     * Soft delete flag - we don't actually delete users.
     * This preserves booking history and audit trails.
     */
    @Builder.Default
    private boolean active = true;
    
    /**
     * Relationship: One user can have many bookings.
     * 
     * mappedBy = "user" tells JPA that the Booking entity owns this relationship
     * (that's where the foreign key is defined).
     * 
     * FetchType.LAZY means bookings are NOT loaded when we load a user.
     * They're only loaded when we access user.getBookings().
     * This prevents loading tons of data we might not need.
     */
    @OneToMany(mappedBy = "user", cascade = CascadeType.ALL, fetch = FetchType.LAZY)
    @Builder.Default
    private List<Booking> bookings = new ArrayList<>();
    
    // ══════════════════════════════════════════════════════════════════════════
    // AUDIT FIELDS
    // ══════════════════════════════════════════════════════════════════════════
    // These are automatically set by Spring Data JPA's auditing feature.
    // Requires @EnableJpaAuditing in a config class.
    
    /**
     * When this user was created.
     * Automatically set on first save.
     */
    @CreatedDate
    @Column(name = "created_at", updatable = false)
    private LocalDateTime createdAt;
    
    /**
     * When this user was last updated.
     * Automatically updated on every save.
     */
    @LastModifiedDate
    @Column(name = "updated_at")
    private LocalDateTime updatedAt;
}
